//
//  The MIT License
//
//  Copyright (c) 2014- High-Mobility GmbH (https://high-mobility.com)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
//
//  AACharging.swift
//  AutoAPI
//
//  Generated by AutoAPIGenerator for Swift.
//  Copyright Â© 2021 High-Mobility GmbH. All rights reserved.
//

import Foundation
import HMUtilities


public final class AACharging: AACapability, AAPropertyIdentifying {

    /// Information about the introduction and last update of this capability.
    public enum API: AAAPICurrent {
        /// Level (version) of *AutoAPI* when `AACharging` was introduced to the spec.
        public static let intro: UInt8 = 2
    
        /// Level (version) of *AutoAPI* when `AACharging` was last updated.
        public static let updated: UInt8 = 12
    }


    /// Charge mode enum.
    public enum ChargeMode: String, CaseIterable, Codable, HMBytesConvertable {
    
        case immediate = "immediate"
        case timerBased = "timerBased"
        case inductive = "inductive"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .immediate: return 0x00
            case .timerBased: return 0x01
            case .inductive: return 0x02
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .immediate
            case 0x01: self = .timerBased
            case 0x02: self = .inductive
            default: return nil
            }
        }
    }

    /// Charging window chosen enum.
    public enum ChargingWindowChosen: String, CaseIterable, Codable, HMBytesConvertable {
    
        case notChosen = "notChosen"
        case chosen = "chosen"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .notChosen: return 0x00
            case .chosen: return 0x01
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .notChosen
            case 0x01: self = .chosen
            default: return nil
            }
        }
    }

    /// Type of current in use.
    public enum CurrentType: String, CaseIterable, Codable, HMBytesConvertable {
    
        case alternatingCurrent = "alternatingCurrent"
        case directCurrent = "directCurrent"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .alternatingCurrent: return 0x00
            case .directCurrent: return 0x01
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .alternatingCurrent
            case 0x01: self = .directCurrent
            default: return nil
            }
        }
    }

    /// Plug type enum.
    public enum PlugType: String, CaseIterable, Codable, HMBytesConvertable {
    
        case type1 = "type1"
        case type2 = "type2"
        case ccs = "ccs"
        case chademo = "chademo"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .type1: return 0x00
            case .type2: return 0x01
            case .ccs: return 0x02
            case .chademo: return 0x03
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .type1
            case 0x01: self = .type2
            case 0x02: self = .ccs
            case 0x03: self = .chademo
            default: return nil
            }
        }
    }

    /// Plugged in enum.
    public enum PluggedIn: String, CaseIterable, Codable, HMBytesConvertable {
    
        case disconnected = "disconnected"
        case pluggedIn = "pluggedIn"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .disconnected: return 0x00
            case .pluggedIn: return 0x01
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .disconnected
            case 0x01: self = .pluggedIn
            default: return nil
            }
        }
    }

    /// Preconditioning error if one is encountered.
    public enum PreconditioningError: String, CaseIterable, Codable, HMBytesConvertable {
    
        case noChange = "noChange"
        case notPossibleLow = "notPossibleLow"
        case notPossibleFinished = "notPossibleFinished"
        case availableAfterEngineRestart = "availableAfterEngineRestart"
        case generalError = "generalError"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .noChange: return 0x00
            case .notPossibleLow: return 0x01
            case .notPossibleFinished: return 0x02
            case .availableAfterEngineRestart: return 0x03
            case .generalError: return 0x04
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .noChange
            case 0x01: self = .notPossibleLow
            case 0x02: self = .notPossibleFinished
            case 0x03: self = .availableAfterEngineRestart
            case 0x04: self = .generalError
            default: return nil
            }
        }
    }

    /// Status of optimized/intelligent charging.
    public enum SmartChargingStatus: String, CaseIterable, Codable, HMBytesConvertable {
    
        case wallboxIsActive = "wallboxIsActive"
        case sccIsActive = "sccIsActive"
        case peakSettingActive = "peakSettingActive"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .wallboxIsActive: return 0x00
            case .sccIsActive: return 0x01
            case .peakSettingActive: return 0x02
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .wallboxIsActive
            case 0x01: self = .sccIsActive
            case 0x02: self = .peakSettingActive
            default: return nil
            }
        }
    }

    /// State of the starter battery.
    public enum StarterBatteryState: String, CaseIterable, Codable, HMBytesConvertable {
    
        case red = "red"
        case yellow = "yellow"
        case green = "green"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .red: return 0x00
            case .yellow: return 0x01
            case .green: return 0x02
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .red
            case 0x01: self = .yellow
            case 0x02: self = .green
            default: return nil
            }
        }
    }

    /// Status enum.
    public enum Status: String, CaseIterable, Codable, HMBytesConvertable {
    
        case notCharging = "notCharging"
        case charging = "charging"
        case chargingComplete = "chargingComplete"
        case initialising = "initialising"
        case chargingPaused = "chargingPaused"
        case chargingError = "chargingError"
        case cableUnplugged = "cableUnplugged"
        case slowCharging = "slowCharging"
        case fastCharging = "fastCharging"
        case discharging = "discharging"
        case foreignObjectDetected = "foreignObjectDetected"
    
    
        public var byteValue: UInt8 {
            switch self {
            case .notCharging: return 0x00
            case .charging: return 0x01
            case .chargingComplete: return 0x02
            case .initialising: return 0x03
            case .chargingPaused: return 0x04
            case .chargingError: return 0x05
            case .cableUnplugged: return 0x06
            case .slowCharging: return 0x07
            case .fastCharging: return 0x08
            case .discharging: return 0x09
            case .foreignObjectDetected: return 0x0a
            }
        }
    
    
        // MARK: HMBytesConvertable
    
        public var bytes: [UInt8] {
            [byteValue]
        }
    
    
        public init?(bytes: [UInt8]) {
            guard let uint8 = UInt8(bytes: bytes) else {
                return nil
            }
    
            switch uint8 {
            case 0x00: self = .notCharging
            case 0x01: self = .charging
            case 0x02: self = .chargingComplete
            case 0x03: self = .initialising
            case 0x04: self = .chargingPaused
            case 0x05: self = .chargingError
            case 0x06: self = .cableUnplugged
            case 0x07: self = .slowCharging
            case 0x08: self = .fastCharging
            case 0x09: self = .discharging
            case 0x0a: self = .foreignObjectDetected
            default: return nil
            }
        }
    }


    // MARK: Identifiers
    
    public class override var identifier: UInt16 { 0x0023 }


    /// Property identifiers for `AACharging`.
    public enum PropertyIdentifier: UInt8, CaseIterable {
        case estimatedRange = 0x02
        case batteryLevel = 0x03
        case chargeLimit = 0x08
        case timeToCompleteCharge = 0x09
        case chargePortState = 0x0b
        case chargeMode = 0x0c
        case maxChargingCurrent = 0x0e
        case plugType = 0x0f
        case chargingWindowChosen = 0x10
        case departureTimes = 0x11
        case reductionTimes = 0x13
        case batteryTemperature = 0x14
        case timers = 0x15
        case pluggedIn = 0x16
        case status = 0x17
        case chargingRate = 0x18
        case batteryCurrent = 0x19
        case chargerVoltage = 0x1a
        case currentType = 0x1b
        case maxRange = 0x1c
        case starterBatteryState = 0x1d
        case smartChargingStatus = 0x1e
        case batteryLevelAtDeparture = 0x1f
        case preconditioningDepartureStatus = 0x20
        case preconditioningImmediateStatus = 0x21
        case preconditioningDepartureEnabled = 0x22
        case preconditioningError = 0x23
    }


    // MARK: Properties
    
    /// Battery current.
    public var batteryCurrent: AAProperty<Measurement<UnitElectricCurrent>>?
    
    /// Battery level percentage between 0.0-1.0.
    public var batteryLevel: AAProperty<AAPercentage>?
    
    /// Battery charge level expected at time of departure.
    public var batteryLevelAtDeparture: AAProperty<AAPercentage>?
    
    /// Battery temperature.
    public var batteryTemperature: AAProperty<Measurement<UnitTemperature>>?
    
    /// Charge limit percentage between 0.0-1.0.
    public var chargeLimit: AAProperty<AAPercentage>?
    
    /// Charge mode value.
    public var chargeMode: AAProperty<ChargeMode>?
    
    /// Charge port state value.
    public var chargePortState: AAProperty<AAPosition>?
    
    /// Charger voltage.
    public var chargerVoltage: AAProperty<Measurement<UnitElectricPotentialDifference>>?
    
    /// Charge rate when charging.
    public var chargingRate: AAProperty<Measurement<UnitPower>>?
    
    /// Charging window chosen value.
    public var chargingWindowChosen: AAProperty<ChargingWindowChosen>?
    
    /// Type of current in use.
    public var currentType: AAProperty<CurrentType>?
    
    /// Departure times value.
    public var departureTimes: [AAProperty<AADepartureTime>]?
    
    /// Estimated range.
    public var estimatedRange: AAProperty<Measurement<UnitLength>>?
    
    /// Maximum charging current.
    public var maxChargingCurrent: AAProperty<Measurement<UnitElectricCurrent>>?
    
    /// Maximum electric range with 100% of battery.
    public var maxRange: AAProperty<Measurement<UnitLength>>?
    
    /// Plug type value.
    public var plugType: AAProperty<PlugType>?
    
    /// Plugged in value.
    public var pluggedIn: AAProperty<PluggedIn>?
    
    /// Preconditioning activation status at departure.
    public var preconditioningDepartureEnabled: AAProperty<AAEnabledState>?
    
    /// Status of preconditioning at departure time.
    public var preconditioningDepartureStatus: AAProperty<AAActiveState>?
    
    /// Preconditioning error if one is encountered.
    public var preconditioningError: AAProperty<PreconditioningError>?
    
    /// Status of immediate preconditioning.
    public var preconditioningImmediateStatus: AAProperty<AAActiveState>?
    
    /// Reduction of charging times value.
    public var reductionTimes: [AAProperty<AAReductionTime>]?
    
    /// Status of optimized/intelligent charging.
    public var smartChargingStatus: AAProperty<SmartChargingStatus>?
    
    /// State of the starter battery.
    public var starterBatteryState: AAProperty<StarterBatteryState>?
    
    /// Status value.
    public var status: AAProperty<Status>?
    
    /// Time until charging completed.
    public var timeToCompleteCharge: AAProperty<Measurement<UnitDuration>>?
    
    /// Timers value.
    public var timers: [AAProperty<AATimer>]?
    
    // Deprecated
    
    /// Battery alternating current.
    ///
    /// - warning: This property is deprecated in favour of *batteryCurrent*.
    @available(*, deprecated, renamed: "batteryCurrent", message: "moved AC/DC distinction into a separate property")
    public var batteryCurrentAC: AAProperty<Measurement<UnitElectricCurrent>>? {
        batteryCurrent
    }
    
    /// Battery direct current.
    ///
    /// - warning: This property is deprecated in favour of *batteryCurrent*.
    @available(*, deprecated, renamed: "batteryCurrent", message: "moved AC/DC distinction into a separate property")
    public var batteryCurrentDC: AAProperty<Measurement<UnitElectricCurrent>>? {
        batteryCurrent
    }
    
    /// Charger voltage for alternating current.
    ///
    /// - warning: This property is deprecated in favour of *chargerVoltage*.
    @available(*, deprecated, renamed: "chargerVoltage", message: "moved AC/DC distinction into a separate property")
    public var chargerVoltageAC: AAProperty<Measurement<UnitElectricPotentialDifference>>? {
        chargerVoltage
    }
    
    /// Charger voltage for direct current.
    ///
    /// - warning: This property is deprecated in favour of *chargerVoltage*.
    @available(*, deprecated, renamed: "chargerVoltage", message: "moved AC/DC distinction into a separate property")
    public var chargerVoltageDC: AAProperty<Measurement<UnitElectricPotentialDifference>>? {
        chargerVoltage
    }
    
    /// Charging rate.
    ///
    /// - warning: This property is deprecated in favour of *chargingRate*.
    @available(*, deprecated, renamed: "chargingRate", message: "removed the unit from the name")
    public var chargingRateKW: AAProperty<Measurement<UnitPower>>? {
        chargingRate
    }


    // MARK: Getters
    
    /// Get `AACharging` state (all properties).
    ///
    /// - returns: The request as `[UInt8]` to send to the vehicle.
    public static func getChargingState() -> [UInt8] {
        AAAutoAPI.protocolVersion.bytes + Self.identifier.bytes + AACommandType.get.rawValue.bytes
    }
    
    /// Get `AACharging` state's specific properties.
    ///
    /// - parameters:
    ///     - ids: List of property identifiers to request.
    ///
    /// - returns: The request as `[UInt8]` to send to the vehicle.
    public static func getChargingStateProperties(ids: PropertyIdentifier...) -> [UInt8] {
        getChargingState() + ids.map { $0.rawValue }
    }
    
    /// Get `AACharging` state properties availability.
    ///
    /// - returns: The request as `[UInt8]` to send to the vehicle.
    public static func getChargingStateAvailability() -> [UInt8] {
        AAAutoAPI.protocolVersion.bytes + Self.identifier.bytes + AACommandType.availability.rawValue.bytes
    }
    
    /// Get `AACharging` state's specific properties' availability.
    ///
    /// - parameters:
    ///     - ids: List of property identifiers to request availability for.
    ///
    /// - returns: The request as `[UInt8]` to send to the vehicle.
    public static func getChargingStatePropertiesAvailability(ids: PropertyIdentifier...) -> [UInt8] {
        getChargingStateAvailability() + ids.map { $0.rawValue }
    }


    // MARK: Setters
    
    /// Start or stop charging, which can only be controlled when the vehicle is plugged in.
    /// 
    /// - parameters:
    ///     - status: Status value.
    ///
    /// - returns: Command as `[UInt8]` to send to the vehicle.
    public static func startStopCharging(status: Status) -> [UInt8] {
        var properties: [AAOpaqueProperty?] = []
    
        properties.append(AAProperty(id: PropertyIdentifier.status, value: status))
    
        let propertiesBytes = properties.compactMap { $0 }.sorted { $0.id < $1.id }.flatMap { $0.bytes }
    
        return setterHeader + propertiesBytes
    }
    
    /// Set the charge limit, to which point the vehicle will charge itself.
    /// 
    /// - parameters:
    ///     - chargeLimit: Charge limit percentage between 0.0-1.0.
    ///
    /// - returns: Command as `[UInt8]` to send to the vehicle.
    public static func setChargeLimit(chargeLimit: AAPercentage) -> [UInt8] {
        var properties: [AAOpaqueProperty?] = []
    
        properties.append(AAProperty(id: PropertyIdentifier.chargeLimit, value: chargeLimit))
    
        let propertiesBytes = properties.compactMap { $0 }.sorted { $0.id < $1.id }.flatMap { $0.bytes }
    
        return setterHeader + propertiesBytes
    }
    
    /// Open or close the charge port of the vehicle.
    /// 
    /// - parameters:
    ///     - chargePortState: Charge port state value.
    ///
    /// - returns: Command as `[UInt8]` to send to the vehicle.
    public static func openCloseChargingPort(chargePortState: AAPosition) -> [UInt8] {
        var properties: [AAOpaqueProperty?] = []
    
        properties.append(AAProperty(id: PropertyIdentifier.chargePortState, value: chargePortState))
    
        let propertiesBytes = properties.compactMap { $0 }.sorted { $0.id < $1.id }.flatMap { $0.bytes }
    
        return setterHeader + propertiesBytes
    }
    
    /// Set the charge mode of the vehicle.
    /// 
    /// - parameters:
    ///     - chargeMode: Charge mode value.
    ///
    /// - returns: Command as `[UInt8]` to send to the vehicle.
    public static func setChargeMode(chargeMode: ChargeMode) -> [UInt8] {
        var properties: [AAOpaqueProperty?] = []
    
        properties.append(AAProperty(id: PropertyIdentifier.chargeMode, value: chargeMode))
    
        let propertiesBytes = properties.compactMap { $0 }.sorted { $0.id < $1.id }.flatMap { $0.bytes }
    
        return setterHeader + propertiesBytes
    }
    
    /// Set the charging timers of the vehicle. The command can include one of the different timer types or all.
    /// 
    /// - parameters:
    ///     - timers: Timers value.
    ///
    /// - returns: Command as `[UInt8]` to send to the vehicle.
    public static func setChargingTimers(timers: [AATimer]) -> [UInt8] {
        var properties: [AAOpaqueProperty?] = []
    
        properties.append(contentsOf: timers.compactMap { AAProperty(id: PropertyIdentifier.timers, value: $0) })
    
        let propertiesBytes = properties.compactMap { $0 }.sorted { $0.id < $1.id }.flatMap { $0.bytes }
    
        return setterHeader + propertiesBytes
    }
    
    /// Set the reduction of charging times of the vehicle. The command can include different values for start and stop.
    /// 
    /// - parameters:
    ///     - reductionTimes: Reduction of charging times value.
    ///
    /// - returns: Command as `[UInt8]` to send to the vehicle.
    public static func setReductionOfChargingCurrentTimes(reductionTimes: [AAReductionTime]) -> [UInt8] {
        var properties: [AAOpaqueProperty?] = []
    
        properties.append(contentsOf: reductionTimes.compactMap { AAProperty(id: PropertyIdentifier.reductionTimes, value: $0) })
    
        let propertiesBytes = properties.compactMap { $0 }.sorted { $0.id < $1.id }.flatMap { $0.bytes }
    
        return setterHeader + propertiesBytes
    }


    // MARK: AACapability
    
    public required init?(bytes: [UInt8]) {
        super.init(bytes: bytes)
    
        batteryCurrent = extract(property: .batteryCurrent)
        batteryLevel = extract(property: .batteryLevel)
        batteryLevelAtDeparture = extract(property: .batteryLevelAtDeparture)
        batteryTemperature = extract(property: .batteryTemperature)
        chargeLimit = extract(property: .chargeLimit)
        chargeMode = extract(property: .chargeMode)
        chargePortState = extract(property: .chargePortState)
        chargerVoltage = extract(property: .chargerVoltage)
        chargingRate = extract(property: .chargingRate)
        chargingWindowChosen = extract(property: .chargingWindowChosen)
        currentType = extract(property: .currentType)
        departureTimes = extract(properties: .departureTimes)
        estimatedRange = extract(property: .estimatedRange)
        maxChargingCurrent = extract(property: .maxChargingCurrent)
        maxRange = extract(property: .maxRange)
        plugType = extract(property: .plugType)
        pluggedIn = extract(property: .pluggedIn)
        preconditioningDepartureEnabled = extract(property: .preconditioningDepartureEnabled)
        preconditioningDepartureStatus = extract(property: .preconditioningDepartureStatus)
        preconditioningError = extract(property: .preconditioningError)
        preconditioningImmediateStatus = extract(property: .preconditioningImmediateStatus)
        reductionTimes = extract(properties: .reductionTimes)
        smartChargingStatus = extract(property: .smartChargingStatus)
        starterBatteryState = extract(property: .starterBatteryState)
        status = extract(property: .status)
        timeToCompleteCharge = extract(property: .timeToCompleteCharge)
        timers = extract(properties: .timers)
    }
}