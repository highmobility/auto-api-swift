//
//  The MIT License
//
//  Copyright (c) 2014- High-Mobility GmbH (https://high-mobility.com)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
//
//  AAAdasTests.swift
//  AutoAPI
//
//  Generated by AutoAPIGenerator for Swift.
//  Copyright Â© 2021 High-Mobility GmbH. All rights reserved.
//

import Foundation
import HMUtilities
import XCTest
@testable import AutoAPI


final class AAAdasTests: XCTestCase {

    // MARK: State Properties
    
    func testStatus() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x01, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.status?.value, AAOnOffState.on)
    }
    
    func testAlertnessSystemStatus() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x02, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.alertnessSystemStatus?.value, AAActiveState.active)
    }
    
    func testForwardCollisionWarningSystem() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x03, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.forwardCollisionWarningSystem?.value, AAActiveState.active)
    }
    
    func testBlindSpotWarningState() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x04, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.blindSpotWarningState?.value, AAActiveState.active)
    }
    
    func testBlindSpotWarningSystemCoverage() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x05, 0x00, 0x04, 0x01, 0x00, 0x01, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.blindSpotWarningSystemCoverage?.value, AAAdasBlindSpotWarningSystemCoverage.regular)
    }
    
    func testRearCrossWarningSystem() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x06, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.rearCrossWarningSystem?.value, AAActiveState.active)
    }
    
    func testAutomatedParkingBrake() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x07, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.automatedParkingBrake?.value, AAActiveState.active)
    }
    
    func testLaneKeepAssistSystem() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x08, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.laneKeepAssistSystem?.value, AAOnOffState.on)
    }
    
    func testLaneKeepAssistsStates() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x09, 0x00, 0x05, 0x01, 0x00, 0x02, 0x00, 0x00, 0x09, 0x00, 0x05, 0x01, 0x00, 0x02, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        guard let laneKeepAssistsStates = capability.laneKeepAssistsStates?.compactMap({ $0.value }) else {
            return XCTFail("Could not get `.laneKeepAssistsStates` values from `AAAdas` capability")
        }
        
        XCTAssertTrue(laneKeepAssistsStates.contains { $0.bytes == AALaneKeepAssistState(location: .left, state: .inactive).bytes })
        XCTAssertTrue(laneKeepAssistsStates.contains { $0.bytes == AALaneKeepAssistState(location: .right, state: .active).bytes })
    }
    
    func testParkAssists() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x0a, 0x00, 0x06, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x06, 0x01, 0x00, 0x03, 0x01, 0x01, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        guard let parkAssists = capability.parkAssists?.compactMap({ $0.value }) else {
            return XCTFail("Could not get `.parkAssists` values from `AAAdas` capability")
        }
        
        XCTAssertTrue(parkAssists.contains { $0.bytes == AAParkAssist(location: .front, alarm: .inactive, muted: .notMuted).bytes })
        XCTAssertTrue(parkAssists.contains { $0.bytes == AAParkAssist(location: .rear, alarm: .active, muted: .notMuted).bytes })
    }
    
    func testBlindSpotWarningSystem() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x01, 0x0b, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAAdas else {
            return XCTFail("Could not parse bytes as `AAAdas`")
        }
        
        XCTAssertEqual(capability.blindSpotWarningSystem?.value, AAOnOffState.on)
    }


    // MARK: Getters
    
    func testGetAdasState() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x00]
        
        XCTAssertEqual(bytes, AAAdas.getAdasState())
    }
    
    func testGetAdasStateAvailability() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x02]
        
        XCTAssertEqual(bytes, AAAdas.getAdasStateAvailability())
    }
    
    func testGetAdasStateProperties() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x00, 0x01]
        let getterBytes = AAAdas.getAdasStateProperties(ids: .status)
        
        XCTAssertEqual(bytes, getterBytes)
    }
    
    func testGetAdasStatePropertiesAvailability() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x6c, 0x02, 0x01]
        let getterBytes = AAAdas.getAdasStatePropertiesAvailability(ids: .status)
        
        XCTAssertEqual(bytes, getterBytes)
    }


    // MARK: Identifiers
    
    func testCapabilityIdentifier() {
        XCTAssertEqual(AAAdas.identifier, 0x006C)
    }
    
    func testPropeertyIdentifiers() {
        XCTAssertEqual(AAAdas.PropertyIdentifier.status.rawValue, 0x01)
        XCTAssertEqual(AAAdas.PropertyIdentifier.alertnessSystemStatus.rawValue, 0x02)
        XCTAssertEqual(AAAdas.PropertyIdentifier.forwardCollisionWarningSystem.rawValue, 0x03)
        XCTAssertEqual(AAAdas.PropertyIdentifier.blindSpotWarningState.rawValue, 0x04)
        XCTAssertEqual(AAAdas.PropertyIdentifier.blindSpotWarningSystemCoverage.rawValue, 0x05)
        XCTAssertEqual(AAAdas.PropertyIdentifier.rearCrossWarningSystem.rawValue, 0x06)
        XCTAssertEqual(AAAdas.PropertyIdentifier.automatedParkingBrake.rawValue, 0x07)
        XCTAssertEqual(AAAdas.PropertyIdentifier.laneKeepAssistSystem.rawValue, 0x08)
        XCTAssertEqual(AAAdas.PropertyIdentifier.laneKeepAssistsStates.rawValue, 0x09)
        XCTAssertEqual(AAAdas.PropertyIdentifier.parkAssists.rawValue, 0x0a)
        XCTAssertEqual(AAAdas.PropertyIdentifier.blindSpotWarningSystem.rawValue, 0x0b)
    }
}
