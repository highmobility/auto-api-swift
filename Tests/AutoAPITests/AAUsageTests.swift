//
//  The MIT License
//
//  Copyright (c) 2014- High-Mobility GmbH (https://high-mobility.com)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//
//
//  AAUsageTests.swift
//  AutoAPI
//
//  Generated by AutoAPIGenerator for Swift.
//  Copyright Â© 2021 High-Mobility GmbH. All rights reserved.
//

import Foundation
import HMUtilities
import XCTest
@testable import AutoAPI


final class AAUsageTests: XCTestCase {

    // MARK: State Properties
    
    func testAverageWeeklyDistance() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x01, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x04, 0x40, 0x84, 0xd4, 0xcc, 0xcc, 0xcc, 0xcc, 0xcd]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.averageWeeklyDistance?.value, Measurement<UnitLength>(value: 666.6, unit: .kilometers))
    }
    
    func testAverageWeeklyDistanceLongRun() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x02, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x04, 0x40, 0x88, 0x4d, 0x99, 0x99, 0x99, 0x99, 0x9a]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.averageWeeklyDistanceLongRun?.value, Measurement<UnitLength>(value: 777.7, unit: .kilometers))
    }
    
    func testAccelerationEvaluation() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x03, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.accelerationEvaluation?.value, 0.7)
    }
    
    func testDrivingStyleEvaluation() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x04, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xec, 0x28, 0xf5, 0xc2, 0x8f, 0x5c, 0x29]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.drivingStyleEvaluation?.value, 0.88)
    }
    
    func testDrivingModesActivationPeriods() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x05, 0x00, 0x0c, 0x01, 0x00, 0x09, 0x00, 0x3f, 0xc9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a, 0x05, 0x00, 0x0c, 0x01, 0x00, 0x09, 0x01, 0x3f, 0xd3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x05, 0x00, 0x0c, 0x01, 0x00, 0x09, 0x02, 0x3f, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a, 0x05, 0x00, 0x0c, 0x01, 0x00, 0x09, 0x03, 0x3f, 0xb9, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a, 0x05, 0x00, 0x0c, 0x01, 0x00, 0x09, 0x04, 0x3f, 0xd3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x05, 0x00, 0x0c, 0x01, 0x00, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        guard let drivingModesActivationPeriods = capability.drivingModesActivationPeriods?.compactMap({ $0.value }) else {
            return XCTFail("Could not get `.drivingModesActivationPeriods` values from `AAUsage` capability")
        }
        
        XCTAssertTrue(drivingModesActivationPeriods.contains { $0.bytes == AADrivingModeActivationPeriod(drivingMode: .regular, period: 0.2).bytes })
        XCTAssertTrue(drivingModesActivationPeriods.contains { $0.bytes == AADrivingModeActivationPeriod(drivingMode: .eco, period: 0.3).bytes })
        XCTAssertTrue(drivingModesActivationPeriods.contains { $0.bytes == AADrivingModeActivationPeriod(drivingMode: .sport, period: 0.1).bytes })
        XCTAssertTrue(drivingModesActivationPeriods.contains { $0.bytes == AADrivingModeActivationPeriod(drivingMode: .sportPlus, period: 0.1).bytes })
        XCTAssertTrue(drivingModesActivationPeriods.contains { $0.bytes == AADrivingModeActivationPeriod(drivingMode: .ecoPlus, period: 0.3).bytes })
        XCTAssertTrue(drivingModesActivationPeriods.contains { $0.bytes == AADrivingModeActivationPeriod(drivingMode: .comfort, period: 0.0).bytes })
    }
    
    func testDrivingModesEnergyConsumptions() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x06, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x00, 0x0c, 0x04, 0x40, 0x34, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x06, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x01, 0x0c, 0x04, 0x40, 0x40, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a, 0x06, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x02, 0x0c, 0x04, 0x40, 0x4b, 0x26, 0x66, 0x66, 0x66, 0x66, 0x66, 0x06, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x03, 0x0c, 0x04, 0x40, 0x50, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x06, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x04, 0x0c, 0x04, 0x40, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x05, 0x0c, 0x04, 0x40, 0x40, 0xd9, 0x99, 0x99, 0x99, 0x99, 0x9a]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        guard let drivingModesEnergyConsumptions = capability.drivingModesEnergyConsumptions?.compactMap({ $0.value }) else {
            return XCTFail("Could not get `.drivingModesEnergyConsumptions` values from `AAUsage` capability")
        }
        
        XCTAssertTrue(drivingModesEnergyConsumptions.contains { $0.bytes == AADrivingModeEnergyConsumption(drivingMode: .regular, consumption: Measurement<UnitEnergy>(value: 20.2, unit: UnitEnergy.kilowattHours)).bytes })
        XCTAssertTrue(drivingModesEnergyConsumptions.contains { $0.bytes == AADrivingModeEnergyConsumption(drivingMode: .eco, consumption: Measurement<UnitEnergy>(value: 33.2, unit: UnitEnergy.kilowattHours)).bytes })
        XCTAssertTrue(drivingModesEnergyConsumptions.contains { $0.bytes == AADrivingModeEnergyConsumption(drivingMode: .sport, consumption: Measurement<UnitEnergy>(value: 54.3, unit: UnitEnergy.kilowattHours)).bytes })
        XCTAssertTrue(drivingModesEnergyConsumptions.contains { $0.bytes == AADrivingModeEnergyConsumption(drivingMode: .sportPlus, consumption: Measurement<UnitEnergy>(value: 64.8, unit: UnitEnergy.kilowattHours)).bytes })
        XCTAssertTrue(drivingModesEnergyConsumptions.contains { $0.bytes == AADrivingModeEnergyConsumption(drivingMode: .ecoPlus, consumption: Measurement<UnitEnergy>(value: 18.0, unit: UnitEnergy.kilowattHours)).bytes })
        XCTAssertTrue(drivingModesEnergyConsumptions.contains { $0.bytes == AADrivingModeEnergyConsumption(drivingMode: .comfort, consumption: Measurement<UnitEnergy>(value: 33.7, unit: UnitEnergy.kilowattHours)).bytes })
    }
    
    func testLastTripEnergyConsumption() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x07, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0c, 0x04, 0x40, 0x59, 0x53, 0x33, 0x33, 0x33, 0x33, 0x33]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.lastTripEnergyConsumption?.value, Measurement<UnitEnergy>(value: 101.3, unit: .kilowattHours))
    }
    
    func testLastTripFuelConsumption() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x08, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x19, 0x02, 0x40, 0x36, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.lastTripFuelConsumption?.value, Measurement<UnitVolume>(value: 22.5, unit: .liters))
    }
    
    func testLastTripElectricPortion() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x0a, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.lastTripElectricPortion?.value, 0.7)
    }
    
    func testLastTripAverageEnergyRecuperation() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x0b, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0d, 0x00, 0x40, 0x16, 0xb8, 0x51, 0xeb, 0x85, 0x1e, 0xb8]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.lastTripAverageEnergyRecuperation?.value, Measurement<UnitEnergyEfficiency>(value: 5.68, unit: .kwhPer100Kilometers))
    }
    
    func testLastTripBatteryRemaining() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x0c, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.lastTripBatteryRemaining?.value, 0.5)
    }
    
    func testLastTripDate() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x0d, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x00, 0x00, 0x01, 0x66, 0x82, 0x05, 0x9d, 0x50]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertNotNil(DateFormatter.hmFormatter.date(from: "2018-10-17T12:34:58.000Z"))
        XCTAssertEqual(capability.lastTripDate?.value, DateFormatter.hmFormatter.date(from: "2018-10-17T12:34:58.000Z"))
    }
    
    func testAverageFuelConsumption() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x0e, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0f, 0x00, 0x40, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.averageFuelConsumption?.value, Measurement<UnitFuelEfficiency>(value: 6.5, unit: .litersPer100Kilometers))
    }
    
    func testCurrentFuelConsumption() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x0f, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0f, 0x00, 0x40, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.currentFuelConsumption?.value, Measurement<UnitFuelEfficiency>(value: 7.5, unit: .litersPer100Kilometers))
    }
    
    func testOdometerAfterLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x10, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x04, 0x40, 0xf7, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.odometerAfterLastTrip?.value, Measurement<UnitLength>(value: 95632.0, unit: .kilometers))
    }
    
    func testSafetyDrivingScore() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x11, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.safetyDrivingScore?.value, 0.7)
    }
    
    func testRapidAccelerationGrade() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x12, 0x00, 0x04, 0x01, 0x00, 0x01, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.rapidAccelerationGrade?.value, AAGrade.excellent)
    }
    
    func testRapidDecelerationGrade() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x13, 0x00, 0x04, 0x01, 0x00, 0x01, 0x01]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.rapidDecelerationGrade?.value, AAGrade.normal)
    }
    
    func testLateNightGrade() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x14, 0x00, 0x04, 0x01, 0x00, 0x01, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.lateNightGrade?.value, AAGrade.excellent)
    }
    
    func testDistanceOverTime() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x15, 0x00, 0x17, 0x01, 0x00, 0x14, 0x12, 0x04, 0x40, 0x97, 0x73, 0x85, 0x1e, 0xb8, 0x51, 0xec, 0x07, 0x04, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.distanceOverTime?.value?.bytes, AADistanceOverTime(distance: Measurement<UnitLength>(value: 1500.88, unit: UnitLength.kilometers), time: Measurement<UnitDuration>(value: 10.0, unit: UnitDuration.weeks)).bytes)
    }
    
    func testElectricConsumptionRateSinceStart() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x16, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0d, 0x00, 0x40, 0x26, 0x70, 0xa3, 0xd7, 0x0a, 0x3d, 0x71]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.electricConsumptionRateSinceStart?.value, Measurement<UnitEnergyEfficiency>(value: 11.22, unit: .kwhPer100Kilometers))
    }
    
    func testElectricConsumptionRateSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x17, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0d, 0x00, 0x40, 0x36, 0x54, 0x7a, 0xe1, 0x47, 0xae, 0x14]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.electricConsumptionRateSinceReset?.value, Measurement<UnitEnergyEfficiency>(value: 22.33, unit: .kwhPer100Kilometers))
    }
    
    func testElectricDistanceLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x18, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x00, 0x40, 0xfb, 0x19, 0x80, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.electricDistanceLastTrip?.value, Measurement<UnitLength>(value: 111000.0, unit: .meters))
    }
    
    func testElectricDistanceSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x19, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x00, 0x41, 0x0b, 0x19, 0x80, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.electricDistanceSinceReset?.value, Measurement<UnitLength>(value: 222000.0, unit: .meters))
    }
    
    func testElectricDurationLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x1a, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x07, 0x01, 0x40, 0x53, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.electricDurationLastTrip?.value, Measurement<UnitDuration>(value: 77.0, unit: .minutes))
    }
    
    func testElectricDurationSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x1b, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x07, 0x01, 0x40, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.electricDurationSinceReset?.value, Measurement<UnitDuration>(value: 88.0, unit: .minutes))
    }
    
    func testFuelConsumptionRateLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x1c, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0f, 0x00, 0x40, 0x15, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.fuelConsumptionRateLastTrip?.value, Measurement<UnitFuelEfficiency>(value: 5.4, unit: .litersPer100Kilometers))
    }
    
    func testFuelConsumptionRateSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x1d, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x0f, 0x00, 0x40, 0x15, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.fuelConsumptionRateSinceReset?.value, Measurement<UnitFuelEfficiency>(value: 5.3, unit: .litersPer100Kilometers))
    }
    
    func testAverageSpeedLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x1e, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x16, 0x01, 0x40, 0x46, 0x19, 0x99, 0x99, 0x99, 0x99, 0x9a]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.averageSpeedLastTrip?.value, Measurement<UnitSpeed>(value: 44.2, unit: .kilometersPerHour))
    }
    
    func testAverageSpeedSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x1f, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x16, 0x01, 0x40, 0x46, 0x19, 0x99, 0x99, 0x99, 0x99, 0x9a]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.averageSpeedSinceReset?.value, Measurement<UnitSpeed>(value: 44.2, unit: .kilometersPerHour))
    }
    
    func testFuelDistanceLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x20, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x00, 0x40, 0xfb, 0x19, 0x80, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.fuelDistanceLastTrip?.value, Measurement<UnitLength>(value: 111000.0, unit: .meters))
    }
    
    func testFuelDistanceSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x21, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x00, 0x41, 0x0b, 0x19, 0x80, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.fuelDistanceSinceReset?.value, Measurement<UnitLength>(value: 222000.0, unit: .meters))
    }
    
    func testDrivingDurationLastTrip() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x22, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x07, 0x01, 0x40, 0x53, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.drivingDurationLastTrip?.value, Measurement<UnitDuration>(value: 77.0, unit: .minutes))
    }
    
    func testDrivingDurationSinceReset() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x23, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x07, 0x01, 0x40, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.drivingDurationSinceReset?.value, Measurement<UnitDuration>(value: 88.0, unit: .minutes))
    }
    
    func testEcoScoreTotal() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x24, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.ecoScoreTotal?.value, 0.7)
    }
    
    func testEcoScoreFreeWheel() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x25, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.ecoScoreFreeWheel?.value, 0.7)
    }
    
    func testEcoScoreConstant() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x26, 0x00, 0x0b, 0x01, 0x00, 0x08, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.ecoScoreConstant?.value, 0.7)
    }
    
    func testEcoScoreBonusRange() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x27, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x04, 0x3f, 0xe6, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        XCTAssertEqual(capability.ecoScoreBonusRange?.value, Measurement<UnitLength>(value: 0.7, unit: .kilometers))
    }
    
    func testTripMeters() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x01, 0x28, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x01, 0x12, 0x04, 0x40, 0x7c, 0x83, 0x33, 0x33, 0x33, 0x33, 0x33, 0x28, 0x00, 0x0e, 0x01, 0x00, 0x0b, 0x02, 0x12, 0x04, 0x40, 0xa3, 0x72, 0x99, 0x99, 0x99, 0x99, 0x9a]
        
        guard let capability = try? AAAutoAPI.parseBytes(bytes) as? AAUsage else {
            return XCTFail("Could not parse bytes as `AAUsage`")
        }
        
        guard let tripMeters = capability.tripMeters?.compactMap({ $0.value }) else {
            return XCTFail("Could not get `.tripMeters` values from `AAUsage` capability")
        }
        
        XCTAssertTrue(tripMeters.contains { $0.bytes == AATripMeter(id: 1, distance: Measurement<UnitLength>(value: 456.2, unit: UnitLength.kilometers)).bytes })
        XCTAssertTrue(tripMeters.contains { $0.bytes == AATripMeter(id: 2, distance: Measurement<UnitLength>(value: 2489.3, unit: UnitLength.kilometers)).bytes })
    }


    // MARK: Non-state or Deprecated Properties
    
    func testMileageAfterLastTrip() {
        let bytes: [UInt8] = [0x09, 0x00, 0x0d, 0x01, 0x00, 0x0a, 0x12, 0x04, 0x40, 0xf7, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00]
        
        guard let property: AAProperty<Measurement<UnitLength>> = AAOpaqueProperty(bytes: bytes)?.property() else {
            return XCTFail("Could not create a property for `.mileageAfterLastTrip`")
        }
        
        XCTAssertEqual(property.value, Measurement<UnitLength>(value: 95632.0, unit: .kilometers))
    }


    // MARK: Getters
    
    func testGetUsage() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x00]
        
        XCTAssertEqual(bytes, AAUsage.getUsage())
    }
    
    func testGetUsageAvailability() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x02]
        
        XCTAssertEqual(bytes, AAUsage.getUsageAvailability())
    }
    
    func testGetUsageProperties() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x00, 0x01]
        let getterBytes = AAUsage.getUsageProperties(ids: .averageWeeklyDistance)
        
        XCTAssertEqual(bytes, getterBytes)
    }
    
    func testGetUsagePropertiesAvailability() {
        let bytes: [UInt8] = [0x0d, 0x00, 0x68, 0x02, 0x01]
        let getterBytes = AAUsage.getUsagePropertiesAvailability(ids: .averageWeeklyDistance)
        
        XCTAssertEqual(bytes, getterBytes)
    }


    // MARK: Identifiers
    
    func testCapabilityIdentifier() {
        XCTAssertEqual(AAUsage.identifier, 0x0068)
    }
    
    func testPropeertyIdentifiers() {
        XCTAssertEqual(AAUsage.PropertyIdentifier.averageWeeklyDistance.rawValue, 0x01)
        XCTAssertEqual(AAUsage.PropertyIdentifier.averageWeeklyDistanceLongRun.rawValue, 0x02)
        XCTAssertEqual(AAUsage.PropertyIdentifier.accelerationEvaluation.rawValue, 0x03)
        XCTAssertEqual(AAUsage.PropertyIdentifier.drivingStyleEvaluation.rawValue, 0x04)
        XCTAssertEqual(AAUsage.PropertyIdentifier.drivingModesActivationPeriods.rawValue, 0x05)
        XCTAssertEqual(AAUsage.PropertyIdentifier.drivingModesEnergyConsumptions.rawValue, 0x06)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lastTripEnergyConsumption.rawValue, 0x07)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lastTripFuelConsumption.rawValue, 0x08)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lastTripElectricPortion.rawValue, 0x0a)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lastTripAverageEnergyRecuperation.rawValue, 0x0b)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lastTripBatteryRemaining.rawValue, 0x0c)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lastTripDate.rawValue, 0x0d)
        XCTAssertEqual(AAUsage.PropertyIdentifier.averageFuelConsumption.rawValue, 0x0e)
        XCTAssertEqual(AAUsage.PropertyIdentifier.currentFuelConsumption.rawValue, 0x0f)
        XCTAssertEqual(AAUsage.PropertyIdentifier.odometerAfterLastTrip.rawValue, 0x10)
        XCTAssertEqual(AAUsage.PropertyIdentifier.safetyDrivingScore.rawValue, 0x11)
        XCTAssertEqual(AAUsage.PropertyIdentifier.rapidAccelerationGrade.rawValue, 0x12)
        XCTAssertEqual(AAUsage.PropertyIdentifier.rapidDecelerationGrade.rawValue, 0x13)
        XCTAssertEqual(AAUsage.PropertyIdentifier.lateNightGrade.rawValue, 0x14)
        XCTAssertEqual(AAUsage.PropertyIdentifier.distanceOverTime.rawValue, 0x15)
        XCTAssertEqual(AAUsage.PropertyIdentifier.electricConsumptionRateSinceStart.rawValue, 0x16)
        XCTAssertEqual(AAUsage.PropertyIdentifier.electricConsumptionRateSinceReset.rawValue, 0x17)
        XCTAssertEqual(AAUsage.PropertyIdentifier.electricDistanceLastTrip.rawValue, 0x18)
        XCTAssertEqual(AAUsage.PropertyIdentifier.electricDistanceSinceReset.rawValue, 0x19)
        XCTAssertEqual(AAUsage.PropertyIdentifier.electricDurationLastTrip.rawValue, 0x1a)
        XCTAssertEqual(AAUsage.PropertyIdentifier.electricDurationSinceReset.rawValue, 0x1b)
        XCTAssertEqual(AAUsage.PropertyIdentifier.fuelConsumptionRateLastTrip.rawValue, 0x1c)
        XCTAssertEqual(AAUsage.PropertyIdentifier.fuelConsumptionRateSinceReset.rawValue, 0x1d)
        XCTAssertEqual(AAUsage.PropertyIdentifier.averageSpeedLastTrip.rawValue, 0x1e)
        XCTAssertEqual(AAUsage.PropertyIdentifier.averageSpeedSinceReset.rawValue, 0x1f)
        XCTAssertEqual(AAUsage.PropertyIdentifier.fuelDistanceLastTrip.rawValue, 0x20)
        XCTAssertEqual(AAUsage.PropertyIdentifier.fuelDistanceSinceReset.rawValue, 0x21)
        XCTAssertEqual(AAUsage.PropertyIdentifier.drivingDurationLastTrip.rawValue, 0x22)
        XCTAssertEqual(AAUsage.PropertyIdentifier.drivingDurationSinceReset.rawValue, 0x23)
        XCTAssertEqual(AAUsage.PropertyIdentifier.ecoScoreTotal.rawValue, 0x24)
        XCTAssertEqual(AAUsage.PropertyIdentifier.ecoScoreFreeWheel.rawValue, 0x25)
        XCTAssertEqual(AAUsage.PropertyIdentifier.ecoScoreConstant.rawValue, 0x26)
        XCTAssertEqual(AAUsage.PropertyIdentifier.ecoScoreBonusRange.rawValue, 0x27)
        XCTAssertEqual(AAUsage.PropertyIdentifier.tripMeters.rawValue, 0x28)
    }
}
